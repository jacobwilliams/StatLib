      SUBROUTINE IPROJ(R, C, B, L, K, EPS1, EPS2, ITMAX1, ITMAX2, NWORK,
     *  W, P, NIT, SUPDIF, DIV, IFAULT)
C
C        ALGORITHM AS228 APPL. STATIST. (1987) VOL. 36, NO. 3
C
      DIMENSION R(L), P(L), C(L, K), B(K), W(NWORK)
C
C        COMPUTES THE I-PROJECTION OF THE VECTOR R
C        ONTO THE INTERSECTION OF K LINEAR INEQUALITY
C        CONSTRAINTS.  THE J-TH CONSTRAINT IS OF THE FORM
C        SUM OVER I OF C(I,J)*P(I) .LE. B(J)
C        THE DATA, R, IS A NON-NEGATIVE VECTOR.
C        THE I-PROJ IS RETURNED IN P, AS A VECTOR OF PROBABILITIES.
C
      DATA ZERO, ZONE /0.0E0, 1.0E0/
      NIT = 0
      TOT = ZERO
      IFAULT = 0
      LK = L * K
      LKL1 = LK + L
      LKL2 = LKL1 + L
      LKL3 = LKL2 + L
      IF (NWORK .LT. LKL3 + K) GOTO 500
C
C        CHECK DATA FOR NEGATIVES, STANDARDIZE DATA (TO SUM TO 1),
C        INITIALIZE INCREMENT ARRAY AND DUAL ESTIMATE ARRAY.
C
      DO 5 J = 1, K
      INDEX = LKL3 + J
      W(INDEX) = ZERO
    5 CONTINUE
      DO 20 I = 1, L
      P(I) = R(I)
      DO 10 J = 1, K
      INDEX = (J - 1) * L + I
      W(INDEX) = ZONE
   10 CONTINUE
      IF (P(I) .LT. ZERO) GOTO 300
      TOT = TOT + P(I)
   20 CONTINUE
      IF (TOT .LE. ZERO) GOTO 300
      DO 30 I = 1, L
   30 P(I) = P(I) / TOT
C
C        CHECK DATA FOR NON-EXISTENCE OF A SOLUTION, AND LOCATE
C        AND INSERT FORCED ZEROS.
C
   35 IFLAG = 0
      DO 50 J = 1, K
      SNEG = ZERO
      SPOS = ZERO
      SZERO = ZERO
      DO 40 I = 1, L
      CMB = C(I, J) - B(J)
      IF (CMB .GT. ZERO) SPOS = SPOS + P(I)
      IF (CMB .LT. ZERO) SNEG = SNEG + P(I)
      IF (CMB .EQ. ZERO) SZERO = SZERO + P(I)
   40 CONTINUE
      IF (SNEG .GT. ZERO) GOTO 50
      IF (SZERO .LE. ZERO) GOTO 400
      IF (SPOS .LE. ZERO) GOTO 50
      DO 45 I = 1, L
      IF (C(I, J) - B(J) .GT. ZERO) P(I) = ZERO
      P(I) = P(I) / SZERO
   45 CONTINUE
      IFLAG = 1
   50 CONTINUE
      IF (IFLAG .EQ. 1) GOTO 35
C
C        PERFORM AN ITERATION:  LINES 100 TO 200
C
  100 SUPDIF = ZERO
      DO 200 J = 1, K
      SUM = ZERO
      DO 110 I = 1, L
      INDEX = LK + I
      W(INDEX) = P(I)
      INDEX = (J - 1) * L + I
      P(I) = P(I) / W(INDEX)
      INDEX = LKL1 + I
      W(INDEX) = C(I, J) - B(J)
      SUM = SUM + P(I)
  110 CONTINUE
      DO 115 I = 1, L
  115 P(I) = P(I) / SUM
C
C        P PASSES DATA TO PROJ, AND RETURNS THE RESULT.
C        W(LK+I) STORES THE PREVIOUS RESULT, FOR COMPARISON.
C        W(LKL1+I) PASSES THE J-TH COLUMN OF THE CONSTRAINT
C        MATRIX TO PROJ.
C        W(LKL2+I) IS WORKSPACE FOR PROJ.
C        W(LKL3+J) IS THE PREVIOUS DUAL ESTIMATE.
C
      INDEX = LKL3 + J
      CALL PROJ(P, W, NWORK, L, LKL1, LKL2, J, W(INDEX), EPS2, ITMAX2,
     *  IFAULT)
      IF (IFAULT .EQ. 2) RETURN
C
C        UPDATE THE INCREMENT ARRAY W(1)-W(LK) AND GET THE GREATEST
C        DIFFERENCE (TO TEST FOR CONVERGENCE).
C
      DO 120 I = 1, L
      IS = (J - 1) * L + I
      INDEX = LK + I
      IF (W(INDEX) .GT. ZERO) W(IS) = W(IS) * P(I) / W(INDEX)
      DIFF = ABS(P(I) - W(INDEX))
      IF (DIFF .GT. SUPDIF) SUPDIF = DIFF
  120 CONTINUE
  200 CONTINUE
C
C        COUNT ITERATIONS, AND CHECK FOR CONVERGENCE.
C
      NIT = NIT + 1
      IF (SUPDIF .GT. EPS1) GOTO 220
C
C        COMPUTE I-DIVERGENCE
C
      DIV = ZERO
      DO 210 I = 1, L
      IF (P(I) .GT. ZERO) DIV = DIV + P(I) * ALOG(P(I) * TOT / R(I))
  210 CONTINUE
      RETURN
  220 IF (NIT .LE. ITMAX1) GOTO 100
      IFAULT = 1
      RETURN
  300 IFAULT = 3
      RETURN
  400 IFAULT = 4
      RETURN
  500 IFAULT = 5
      RETURN
      END
C
      SUBROUTINE PROJ(P, W, NWORK, L, LKL1, LKL2, J, ZLAST, EPS2,
     *  ITMAX2, IFAULT)
C
C        ALGORITHM AS228 APPL. STATIST. (1987) VOL. 36, NO. 3
C
      DIMENSION P(L), W(NWORK)
      DATA ZERO /0.0E0/
C
C        THIS SUBROUTINE FINDS THE I-PROJ OF P SUBJECT TO THE LINEAR
C        CONSTRAINT IN W -- OF THE FORM
C        SUM OVER I OF W(LKL1+I)*P(I) .LE. ZERO.
C        THE FENCHEL DUAL SOLUTION IS OBTAINED BY NEWTON'S METHOD,
C        TO WITHIN EPS2, WHICH IS THEN USED TO CONSTRUCT THE I-PROJ.
C
      ITER = 0
      IFAULT = 0
      VAL = ZERO
      DERIV = ZERO
      DO 10 I = 1, L
      IND1 = LKL1 + I
      IND2 = LKL2 + I
      W(IND2) = P(I) * W(IND1)
      VAL = VAL + W(IND2)
      DERIV = DERIV - W(IND1) * W(IND2)
   10 CONTINUE
      IF (VAL .GT. ZERO) GOTO 100
C
C        IF VAL .LE. 0 THEN CONSTRAINT IS SATISFIED; RETURN.
C
      ZLAST = ZERO
      RETURN
C
C        THE ITERATION BLOCK:  LINES 100 TO 110.
C
  100 Z = ZLAST - VAL / DERIV
      IF (ABS(Z - ZLAST) .LE. EPS2) GOTO 200
      IF (ITER .GT. ITMAX2) GOTO 300
      ZLAST = Z
      VAL = ZERO
      DERIV = ZERO
      ITER = ITER + 1
      DO 110 I = 1, L
      IND1 = LKL1 + I
      IND2 = LKL2 + I
      TEMP = EXP(-Z * W(IND1))
      VAL = VAL + W(IND2) * TEMP
      DERIV = DERIV - W(IND1) * W(IND2) * TEMP
  110 CONTINUE
      GOTO 100
C
C        GENERATE PROJECTION, STANDARDIZE AND RETURN.
C
  200 SUM = ZERO
      DO 210 I = 1, L
      INDEX = LKL1 + I
      P(I) = P(I) * EXP(-Z * W(INDEX))
      SUM = SUM + P(I)
  210 CONTINUE
      DO 220 I = 1, L
  220 P(I) = P(I) / SUM
      RETURN
  300 IFAULT = 2
      RETURN
      END
