	SUBROUTINE INIT(X, N, XLEN, NCLUS, MXCLUS, MXSIZE, ITYPE,
     *  CLUS, Y, SIZE, P, IOLD, INEW, IFAULT)
C
C	  ALGORITHM AS 140.1 APPL. STATIST. (1979) VOL.28, NO.2
C
C	  CONSTRUCT AN INITIAL PARTITION OF THE NODES
C
	INTEGER XLEN, FIRST, X(XLEN), Y(XLEN), CLUS(N), SIZE(MXCLUS),
     *  INEW(N), IOLD(N)
	REAL P(MXCLUS, MXCLUS)
	LOGICAL FLAG
C
C	  CHECK INPUTS
C
	IFAULT = 1
	IF (NCLUS .LE. 1 .OR. NCLUS .GE. N .OR. NCLUS .GT. MXCLUS) RETURN
	IFAULT = 2
	IF (NCLUS * MXSIZE .LE. N) RETURN
	IFAULT = 3
	DO 1 I = 2, N
	L = I - 1
	IF (X(I) .LE. X(L)) RETURN
1	CONTINUE
	M = N + 1
	IF (X(1) .NE. M .OR. X(N) .GT. XLEN) RETURN
	IFAULT = 4
	DO 2 I = M, XLEN
	IF (X(I) .LE. 0 .OR. X(I) .GT. N) RETURN
2	CONTINUE
	IFAULT = 5
	DO 5 I = 1, N
	FIRST = X(I)
	L = I + 1
	LAST = X(L) - 1
	IF (I .EQ. N) LAST = XLEN
	IF (FIRST .EQ. LAST) GOTO 5
	JLAST = LAST - 1
	DO 4 J = FIRST, JLAST
	JTEST = X(J)
	KFIRST = J + 1
	DO 3 K = KFIRST, LAST
	IF (JTEST .EQ. X(K)) RETURN
3	CONTINUE
4	CONTINUE
5	CONTINUE
C
C	  CONSTRUCT Y VECTOR.  THE Y VECTOR HOLDS THE ASSOCIATION
C	  MATRIX BY COLUMNS RATHER THAN BY ROWS AS X DOES.
C
	DO 6 I = 1, N
	INEW(I) = 0
	Y(I) = N + 1
6	CONTINUE
	Y(M) = 0
	DO 7 I = 1, N
	FIRST = X(I)
	LAST = X(I + 1) - 1
	IF (I .EQ. N) LAST = XLEN
	DO 7 J = FIRST, LAST
	KFIRST = X(J) + 1
	DO 7 K = KFIRST, N
	Y(K) = Y(K) + 1
7	CONTINUE
	DO 8 I = 1, N
	FIRST = X(I)
	LAST = X(I + 1) - 1
	IF (I .EQ. N) LAST = XLEN
	DO 8 J = FIRST, LAST
	ITEMP = X(J)
	L = Y(ITEMP) + INEW(ITEMP)
	Y(L) = I
	INEW(ITEMP) = INEW(ITEMP) + 1
8	CONTINUE
	IFAULT = 6
	DO 9 I = 2, N
	IF (Y(I) .LE. Y(I - 1)) RETURN
9	CONTINUE
	IF (Y(1) .NE. M .OR. Y(N) .GT. XLEN) RETURN
	IF (ITYPE .EQ. 1) GOTO 33
	IFAULT = 0
C
C	  APPROXIMATE FIRST EIGENVECTOR
C
	DO 11 I = 1, N
11	IOLD(I) = 1
	DO 13 ITER = 1, 8
	DO 12 I = 1, N
	LAST = X(I + 1) - 1
	IF (I .EQ. N) LAST = XLEN
	DO 12 J = FIRST, LAST
	ITEMP = X(J)
	INEW(I) = INEW(I) + IOLD(ITEMP)
12	CONTINUE
	DO 13 I = 1, N
	IOLD(I) = INEW(I)
13 	CONTINUE
C
C	  SORT BY FIRST EIGENVECTOR
C
	DO 14 I = 1, N
14	INEW(I) = I
	DO 16 I = 1, N
	FLAG = .TRUE.
	DO 15 J = 2, N
	L = J - 1
	ITEMP = INEW(L)
	M = INEW(J)
	IF (IOLD(M) .GE. IOLD(ITEMP)) GOTO 15
	FLAG = .FALSE.
	INEW(J) = INEW(L)
	INEW(L) = M
15	CONTINUE
	IF (FLAG) GOTO 17
16	CONTINUE
C
C	  PARTITION INTO INITIAL CLUSTERS
C
17	KSTART = N / NCLUS
	DO 21 I = 1, NCLUS
21	SIZE(I) = KSTART
	ILAST = MOD(N, NCLUS)
	IF (ILAST .EQ. 0) GOTO 31
	DO 22 I = 1, ILAST
22	SIZE(I) = SIZE(I) + 1
31	J = 1
	DO 32 I = 1, NCLUS
	KLAST = SIZE(I)
	DO 32 K = 1, KLAST
	ITEMP = INEW(J)
	CLUS(ITEMP) = I
	J = J + 1
32	CONTINUE
	GOTO 40
33	DO 34 I = 1, NCLUS
34	SIZE(I) = 0
	IFAULT = 7
	DO 35 I = 1, N
	J = CLUS(I)
	IF (J .LE. 0 .OR. J .GT. NCLUS) RETURN
	SIZE(J) = SIZE(J) + 1
35	CONTINUE
	IFAULT = 8
	DO 36 I = 1, NCLUS
	IF (SIZE(I) .LE. 0 .OR. SIZE(I) .GT. MXSIZE) RETURN
36	CONTINUE
	IFAULT = 0
C
C	  SET UP P MATRIX, SUCCESS COUNTS
C
40	DO 41 I = 1, NCLUS
	DO 41 J = 1, NCLUS
41	P(I, J) = 0.0
	DO 42 I = 1, N
	FIRST = X(I)
	LAST = X(I + 1) - 1
	IF (I .EQ. N) LAST = XLEN
	DO 42 J = FIRST, LAST
	IF (X(J) .EQ. I) GOTO 42
	ITEMP = X(J)
	ITEMP = CLUS(ITEMP)
	ITEMP2 = CLUS(I)
	P(ITEMP2, ITEMP) = P(ITEMP2, ITEMP) + 1.0
42	CONTINUE
	RETURN
	END
C
	SUBROUTINE ALLOC(X, Y, N, XLEN, NCLUS, MXCLUS, MXSIZE,
     *  TH, MXS2, CLUS, SIZE, P, R1, R2, TLOG, IOLD, INEW)
C
C	  ALGORITHM AS 140.2 APPL. STATIST. (1979) VOL.28, NO.2
C
C	  FROM AN INITIAL PARTITION OF THE NODES OF A GRAPH,
C	  REALLOCATE NODES TO CLUSTERS TO FIND A LOCALLY
C	  MAXIMUM LIKELIHOOD PARTITION
C
	INTEGER XLEN, FIRST, X(XLEN), Y(XLEN), CLUS(N),
     *  SIZE(MXCLUS), IOLD(N), INEW(N)
	REAL P(MXCLUS, MXCLUS), TLOG(MXS2), R1(MXCLUS), R2(MXCLUS)
	LOGICAL GLOBAL
C
C	  INITIALIZE TLOG, INEW, IOLD, PASS.
C
	DO 1 I = 1, MXS2
1	TLOG(I) = FLOAT(I) * ALOG(FLOAT(I))
2	DO 3 I = 1, NCLUS
	INEW(I) = 0
	IOLD(I) = 1
3	CONTINUE
	GLOBAL = .TRUE.
C
C	  MOVE A NODE TO A NEW CLUSTER IF THE MOVE INCREASES
C	  THE LIKELIHOOD.
C	  ONLY CHECK MOVES IF ONE OF THE CLUSTERS HAS IOLD = 1.
C
4	DO 59 ITER = 1, N
	NBEST = CLUS(ITER)
	BTEST = TH
C
C	  SET UP ARRAY OF ASSOCIATIONS (R) FOR THIS NODE
C
	DO 10 I = 1, NCLUS
	R1(I) = 0.0
	R2(I) = 0.0
10	CONTINUE
	FIRST = X(ITER)
	L = ITER + 1
	LAST = X(L) - 1
	IF (ITER .EQ. N) LAST = XLEN
	DO 11 I = FIRST, LAST
	IF (X(I) .EQ. ITER) GOTO 11
	ITEMP = X(I)
	ITEMP = CLUS(ITEMP)
	R1(ITEMP) = R1(ITEMP) + 1.0
11	CONTINUE
	FIRST = Y(ITER)
	LAST = Y(L) - 1
	IF (ITER .EQ. N) LAST = XLEN
	DO 12 I = FIRST, LAST
	IF (Y(I) .EQ. ITER) GOTO 12
	ITEMP = Y(I)
	ITEMP = CLUS(ITEMP)
	R2(ITEMP) = R2(ITEMP) + 1.0
12	CONTINUE
C
C	  CHECK EACH CLUSTER FOR AN INCREASE IN LIKELIHOOD
C
	L = CLUS(ITER)
	DO 49 M = 1, NCLUS
	IF (L .EQ. M .OR. SIZE(M) .GE. MXSIZE .OR.
     *  IOLD(L) + IOLD(M) .EQ. 0) GOTO 49
	TEST = 0.0
	DO 20 J = 1, NCLUS
	IF (J .EQ. L .OR. J .EQ. M) GOTO 20
	IF (P(L, J) .GT. 0.0) TEST = TEST + XLIKE(P(L, J), R1(J), SIZE(L),
     *  SIZE(J), SIZE(L) - 1, SIZE(J), 1.0, TLOG, MXS2)
	IF (P(M, J) .GT. 0.0 .OR. R1(J) .GT. 0.0) TEST = TEST +
     *  XLIKE(P(M, J), R1(J), SIZE(M), SIZE(J), SIZE(M) + 1, SIZE(J),
     *  -1.0, TLOG, MXS2)
	IF (P(J, L) .GT. 0.0) TEST = TEST + XLIKE(P(J, L), R2(J), SIZE(L),
     *  SIZE(J), SIZE(L) - 1, SIZE(J), 1.0, TLOG, MXS2)
	IF (P(J, M) .GT. 0.0 .OR. R2(J) .GT. 0.0) TEST = TEST +
     *  XLIKE(P(J, M), R2(J), SIZE(M), SIZE(J), SIZE(M) + 1, SIZE(J),
     *  -1.0, TLOG, MXS2)
20	CONTINUE
	TEST = TEST + XLIKE(P(L, L), R1(L) + R2(L) , SIZE(L) - 1, SIZE(L),
     *  SIZE(L) - 1, SIZE(L) - 2, 1.0, TLOG, MXS2) +
     *  XLIKE(P(L, M), R1(M) - R2(L) , SIZE(L), SIZE(M), SIZE(L) - 1,
     *  SIZE(M) + 1, 1.0, TLOG, MXS2) +
     *  XLIKE(P(M, L), R2(M) - R1(L) , SIZE(L), SIZE(M), SIZE(L) - 1,
     *  SIZE(M) + 1, -1.0, TLOG, MXS2) +
     *  XLIKE(P(M, M), R1(M) + R2(M) , SIZE(M) - 1, SIZE(M),
     *  SIZE(M) + 1, SIZE(M), -1.0, TLOG, MXS2)
	IF (TEST .LE. BTEST) GOTO 49
	BTEST = TEST
	NBEST = M
49	CONTINUE
C
C	  MOVE TO BEST CLUSTER
C
	IF (NBEST .EQ. L) GOTO 59
	M = NBEST
	DO 50 II = 1, NCLUS
	P(L, II) = P(L, II) - R1(II)
	P(M, II) = P(M, II) + R1(II)
	P(II, L) = P(II, L) - R2(II)
	P(II, M) = P(II, M) + R2(II)
50 	CONTINUE
	SIZE(L) = SIZE(L) - 1
	SIZE(M) = SIZE(M) + 1
	CLUS(ITER) = NBEST
	INEW(L) = 1
	INEW(M) = 1
59	CONTINUE
C
C	  CHECK FOR OPTIMUM, WERE THERE ANY MOVES THIS PASS.
C
	DO 60 I = 1, NCLUS
	IF (INEW(I) .GT. 0) GOTO 62
60	CONTINUE
C
C	  NO MOVES, IF A GLOBAL CHECK, FINISH,
C	  IF A LOCAL CHECK, MAKE A GLOBAL CHECK.
C
	IF (GLOBAL) GOTO 70
	GOTO 2
C
C	  SOME MOVES, RESET IOLD, INEW, MAKE A LOCAL CHECK.
62	GLOBAL = .FALSE.
	DO 63 I = 1, NCLUS
	IOLD(I) = INEW(I)
	INEW(I) = 0
63	CONTINUE
	GOTO 4
C
C	COMPUTE OVERALL LOG LIKELIHOOD
C
70	R1(I) = 0.0
	DO 72 I = 1, NCLUS
	R1(1) = R1(1) + XLIKE(0.0, P(I, I), I, I, SIZE(I) - 1,
     *  SIZE(I), -1.0, TLOG, MXS2)
	DO 71 J = 1, NCLUS
	IF (I .NE. J) R1(1) = R1(1) + XLIKE(0.0, P(I, J),
     *  I, I, SIZE(I), SIZE(J), -1.0, TLOG, MXS2)
71	CONTINUE
72	CONTINUE
	RETURN
	END
C
	REAL FUNCTION XLIKE(P1, R1, S1, S2, S3, S4, Y1, TLOG, MXS2)
C
C	  ALGORITHM AS 140.3 APPL. STATIST. (1979) VOL.28, NO.2
C
C	  EVALUATE THE CHANGE IN LOG LIKELIHOOD BETWEEN P SUCCESSES IN
C	  S1 * S2 TRIALS AND P1 - Y1 * R1 SUCCESSES IN S3 * S4 TRIALS.
C
	INTEGER S1, S2, S3, S4, P, R, X, Z
	REAL TLOG(MXS2)
	XLIKE = 0.0
	P = P1
	Z = S1 * S2
	R = Z - P
	IF (R .NE. 0 .AND. P .NE. 0) XLIKE = TLOG(Z) - TLOG(P) - TLOG(R)
	X = P1 - Y1 * R1
	Z = S3 * S4
	R = Z - X
	IF (R .NE. 0 .AND. X .NE. 0)
     *  XLIKE = XLIKE + TLOG(X) + TLOG(R) - TLOG(Z)
	RETURN
	END

