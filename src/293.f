      SUBROUTINE CNV2XK(IK, K, MC, MXC, MXR, MS, MZ, MD, LGE, ITAB, ISC,
     *                  LBUF, CBUF, X, DS, LFACT, II, K1, K2, IERR)
C
C        ALGORITHM AS 293.1 APPL.STATIST. (1994), VOL.43, NO.3
C
C        Convolves conditional distributions generated by
C        several 2xK tables
C
      INTEGER IK, K, MC, MXC, MXR, MS, MZ, MD, ITAB(MS, 2, MC), ISC,
     *        LBUF(0:1, 0:MXR, 2), X(MC, 0:2), II, K1, K2, IERR
      REAL LGE, CBUF(0:1, 0:MZ), DS(0:1, 0:MD), LFACT(MXC+1)
C
      INTEGER I, IAA, IH1, IH2, IKK, ILS, IMC, IMM, IMR, IXX, IZ1, IZ2,
     *        J, JJ, JR, KK
      REAL DD1, DD2, DSMX, EL, HYMAX, ONE, SUMLG, Y, ZERO, ZEXP, ZLOG
C
      DATA ONE, ZERO / 1.0E + 00, 0.0E + 00 /
C
      EXTERNAL SUMLG
C
      ZEXP(Y) = EXP(Y)
      ZLOG(Y) = ALOG(Y)
C
      IERR = 0
C
C        Check input parameters
C
      IF (IK .GT. MS) IERR = 1
      IF (K .GT. MC) IERR = 2
      IAA = 0
      DO 20 I = 1, IK
         IMM = 0
         IMR = 0
         DO 10 J = 1, K
            IMM = IMM + ITAB(I, 1, J) + ITAB(I, 2, J)
            IMR = IMR + ITAB(I, 2, J)
            IMC = ITAB(I, 1, J) + ITAB(I, 2, J)
            IF (IMC .GT. MXC) IERR = 3
            IAA = MAX0(IAA, IMC)
   10    CONTINUE
         IF (IMR .GT. MXR) IERR = 4
   20 CONTINUE
      IF (IERR .GT. 0) RETURN
C
      DD1 = 10 * ONE
      EL = LGE * ZLOG(DD1)
C
C        Compute log-factorials:
C           LFACT(I) = LOG( (I - 1)! )
C
      LFACT(1) = ZERO
      DO 30 I = 2, IAA + 1
         DD1 = I - 1
         LFACT(I) = LFACT(I - 1) + ZLOG(DD1)
   30 CONTINUE
C
C        Initialize and set scale indicator
C
      II = 0
      JJ = 1
      IR = 0
      K1 = 0
      DS(0, 0) = ONE / ZEXP(EL)
      DSMX = ZERO - EL
      ILS = 0
C
C        For strata = 1, ..., IK, compute sub-distributions and
C        perform convolution in a recursive fashion
C
      DO 160 I = 1, IK
C
C        Extract the ith stratum
C
         IAA = 0
         IKK = 0
         DO 40 J = 1, K
            X(J, 0) = ITAB(I, 1, J)
            X(J, 1) = ITAB(I, 2, J)
            IKK = IKK + X(J, 1)
            IAA = IKK + X(J, 0)
   40    CONTINUE
C
C        Log-scale check
C
         IF (ILS .EQ. 1) GOTO 110
C
C        Check for overflow in ith conditional distribution
C
         HYMAX = LFACT(IAA + 1) - LFACT(IKK + 1)
         HYMAX = HYMAX - LFACT(IAA - IKK + 1)
         IF (HYMAX .GT. EL) ILS = 1
         CALL EX2XK(K, MC, MXC, MXR, MZ, ILS, EL, X, CBUF, LBUF, LFACT,
     *              IP, ISC, IZ1, IZ2, IERR)
         IF (IERR .GT. 0) RETURN
C
C        Lower and upper limits for convolution
C
         K1 = K1 + IZ1
         IZ2 = IZ2 - IZ1
         K2  = IR + IZ2
         IF (K2 .GT. MD) THEN
            IERR = 5
            RETURN
         ENDIF
         IF (ILS .EQ. 1) GOTO 90
C
C        Check for potential overflow in ith convolution
C
         IF (IZ2 .LT. IR) THEN
            IXX = IZ2 + 1
         ELSE
            IXX = IR + 1
         ENDIF
         DD1 = IXX
         DD1 = ZLOG(DD1)
         DSMX = DSMX + HYMAX + DD1
         IF (DSMX .GE. (EL - ONE)) THEN
            ILS = 1
            GOTO 70
         ENDIF
C
C        Perform convolution on natural scale
C
         DSMX = ZERO - EL
         DO 60 J = 0, K2
            IF (J .GT. IZ2) THEN
               IH1 = J - IZ2
            ELSE
               IH1 = 0
            ENDIF
            IF (J .LT. IR) THEN
               IH2 = J
            ELSE
               IH2 = IR
            ENDIF
            DS(JJ, J) = DS(II, IH1) * CBUF(IP, J - IH1)
            DO 50 JR = IH1 + 1, IH2
               DD1 = DS(II, JR) * CBUF(IP, J - JR)
               DS(JJ, J) = DS(JJ, J) + DD1
   50       CONTINUE
            IF (DS(JJ, J) .GT. ZEXP(-EL)) THEN
               DD1 = ZLOG(DS(JJ, J))
            ELSE
               DD1 = -EL
            ENDIF
            IF (DD1 .GT. DSMX) DSMX = DD1
   60    CONTINUE
         GOTO 150
C
C        Convert ith stratum distribution to log-scale
C
   70    CONTINUE
         DO 80 KK = 0, IR
            CBUF(IP, KK) = ZLOG(CBUF(IP, KK))
   80    CONTINUE
C
C        Convert (i-1)th cumulated distribution to log-scale
C
   90    CONTINUE
         DO 100 KK = 0, IR
            DS(II, KK) = EL + ZLOG(DS(II, KK))
  100    CONTINUE
         DSMX = EL + DSMX
         GOTO 120
C
C        Perform convolution on logarithmic scale
C
  110    CONTINUE
         CALL EX2XK(K, MC, MXC, MXR, MZ, ILS, EL, X, CBUF, LBUF, LFACT,
     *              IP, ISC, IZ1, IZ2, IERR)
         IF (IERR .GT. 0) RETURN
         K1 = K1 + IZ1
         IZ2 = IZ2 - IZ1
         K2 = IR + IZ2
         IF (K2 .GT. MD) THEN
            IERR = 5
            RETURN
         ENDIF
  120    CONTINUE
         DO 140 J = 0, K2
            IF (J .GT. IZ2) THEN
               IH1 = J - IZ2
            ELSE
               IH1 = 0
            ENDIF
            IF (J .LT. IR) THEN
               IH2 = J
            ELSE
               IH2 = IR
            ENDIF
            DS(JJ, J) = DS(II, IH1) + CBUF(IP, J - IH1)
            DO 130 JR = IH1 + 1, IH2
               DD1 = DS(II, JR) + CBUF(IP, J - JR)
               DD2 = DS(JJ, J)
               DS(JJ, J) = SUMLG(DD1, DD2)
  130       CONTINUE
  140    CONTINUE
C
C        Reset for next step
C
  150    II = JJ
         JJ = 1 - II
         IR = K2
  160 CONTINUE
C
C        Normalize final distribution
C
      IF (ILS .NE. 1) THEN
         DO 170 I = 0, K2
            IF (DS(II, I) .EQ. ZERO) THEN
               DS(II, I) = -EL
            ELSE
               DS(II, I) = EL + ZLOG(DS(II, I))
            ENDIF
  170    CONTINUE
      ENDIF
      DSMX = DS(II, 0)
      DO 180 I = 1, K2
         DD1 = DS(II, I)
         IF (DD1 .EQ. -EL) GOTO 180
         DD2 = SUMLG(DSMX, DD1)
         DSMX = DD2
  180 CONTINUE
      DO 190 I = 0, K2
         IF (DS(II, I) .EQ. -EL) GOTO 190
         DS(II, I) = DS(II, I) - DSMX
  190 CONTINUE
      K2 = K1 + K2
      RETURN
      END
C
      SUBROUTINE EX2XK(K, MC, MXC, MXR, MZ, ILS, EL, X, CBUF, LBUF,
     *                 LFACT, IP, ISC, IZ1, IZ2, IERR)
C
C        ALGORITHM AS 293.2 APPL.STATIST. (1994), VOL.43, NO.3
C
C        Recursively generates the exact distribution for a single
C        ordered 2xK table using a bivariate shift algorithm
C
      INTEGER K, MC, MXC, MXR, MZ, ILS, X(MC, 0:2),
     *        LBUF(0:1, 0:MXR, 2), IP, ISC, IZ1, IZ2, IERR
      REAL EL, CBUF(0:1, 0:MZ), LFACT(MXC + 1)
C
      INTEGER I, IJ, ILL, ILT(0:1), IMI, IMN, IS, ISS, IS1, IS2,
     *        IST(0:1), IT, ITT, IT1, IT2, IXT, J, JP, LADR, LLL, NI,
     *        TO(0:1)
      REAL ADD, BNM, CCC, ONE, SL, SUM, SUMLG, Y, ZERO, ZEXP
C
      DATA ONE, ZERO / 1.0E + 00, 0.0E + 00 /
C
      EXTERNAL BNM, LADR, SUMLG
C
      ZEXP(Y) = EXP(Y)
C
      SL = ZERO - EL
C
C        Construct the data matrix ordered scores set in x(i,2)
C
      DO 10 I = 1, K
         X(I, 0) = X(I, 0) + X(I, 1)
         IF (ISC .EQ. 1) X(I, 2) = I - 1
         IF (ISC .EQ. 2) X(I, 2) = (I - 1) * (I - 1)
         IF (ISC .EQ. 3) X(I, 2) = 2 ** (I - 1)
   10 CONTINUE
C
C        to(j) : observed value of sufficient statistics
C
      DO 20 J = 0, 1
         TO(J) = 0
   20 CONTINUE
      DO 30 I = 1, K
         TO(0) = TO(0) + X(I, 1)
         TO(1) = TO(1) + X(I, 1) * X(I, 2)
   30 CONTINUE
C
C        Scale factor: ils
C        Set record for initial stage
C           jp - current record indicator
C           ip - past record indicator
C
      DO 40 J=0, MZ
         IF (ILS .EQ. 0) THEN
            CBUF(0, J) = ZERO
         ELSE
            CBUF(0, J) = SL
         ENDIF
   40 CONTINUE
      DO 50 J=0, MXR
         LBUF(0, J, 1) = 0
         LBUF(0, J, 2) = 0
         LBUF(1, J, 1) = 0
         LBUF(1, J, 2) = 0
   50 CONTINUE
C
      IMN = 0
      DO 60 I=1, K
         IMN = IMN + X(I, 0)
   60 CONTINUE
      IMI = 0
C
C        ij - current stage (ij <= k)
C        ip - previous stage indicator
C        jp - current stage indicator
C
      IJ = 0
      IP = 0
      JP = 1 - IP
      IS = 0
      IST(IP) = 0
      ILT(IP) = 0
C
C        Smallest t for s=is
C        Address of largest t with s=is
C
      LBUF(IP, IS, 1) = 0
      LBUF(IP, IS, 2) = 0
C
C        Store the initial distribution
C
      LLL = 0
      IF (ILS .EQ. 0) THEN
         CBUF(IP, LLL) = ONE
      ELSE
         CBUF(IP, LLL) = ZERO
      ENDIF
C
C        Perform the recursions for obtaining the conditional
C        distribution
C
   70 IJ = IJ + 1
C
C        Compute lower and upper bounds for s
C
      IMI = IMI + X(IJ, 0)
      IS1 = MAX0(0, IMI + TO(0) - IMN)
      IS2 = MIN0(TO(0), IMI)
C
C        ist(jp) - smallest value of s for current stage
C        ilt(jp) - largest value of s for current stage
C
      IST(JP) = IS1
      ILT(JP) = IS2
      DO 100 IS = IS1, IS2
C
C        Compute minimum (it1) and maximum (it2) of t given s and
C        set buffer limits for this stage
C
         CALL OPT(MC, IJ, IS, X, IT1, IT2)
         LBUF(JP, IS, 1) = IT1
         IXT = IT2 - IT1
         IF (IS .EQ. IS1) THEN
            LBUF(JP, IS, 2) = IXT
         ELSE
            LBUF(JP, IS, 2) = LBUF(JP, IS - 1, 2) + IXT + 1
         ENDIF
C
C        Perform recursion
C
         NI = X(IJ, 0)
         IZ1 = MAX0(0, IS - ILT(IP))
         IZ2 = MIN0(NI, IS - IST(IP))
         DO 90 IT = IT1, IT2
            IF (ILS .EQ. 0) THEN
               SUM = ZERO
            ELSE
               SUM = SL
            ENDIF
            DO 80 KK = IZ1, IZ2
               ISS = IS - KK
               ITT = IT - KK * X(IJ, 2)
               ILL = LBUF(IP, ISS, 1)
               IF (ITT .LT. ILL) GOTO 80
               ILL = ILL + LBUF(IP, ISS, 2)
               IF (ISS .GT. IST(IP)) THEN
                  ILL = ILL - LBUF(IP, ISS - 1, 2) - 1
               ENDIF
               IF (ITT .GT. ILL) GOTO 80
               LLL = LADR(ISS, ITT, IP, LBUF, IST, MXR)
               CCC = CBUF(IP, LLL)
               IF (ILS. EQ. 0) THEN
                  IF (CCC .EQ. ZERO) GOTO 80
               ELSE
                  IF (CCC .EQ. SL) GOTO 80
               ENDIF
               ADD = BNM(KK, NI, LFACT, MXC)
               IF (ILS .EQ. O) THEN
                  ADD = ZEXP(ADD)
                  ADD = ADD * CCC
                  SUM = SUM + ADD
               ELSE
                  ADD = ADD + CCC
                  SUM = SUMLG(SUM, ADD)
               ENDIF
   80       CONTINUE
            LLL = LADR(IS, IT, JP, LBUF, IST, MXR)
            IF (LLL .GE. MZ) THEN
               IERR = 6
               RETURN
            ENDIF
            CBUF(JP, LLL) = SUM
   90    CONTINUE
  100 CONTINUE
C
C        Check if final stage is reached
C
      IF (IJ .GE. K) GOTO 110
C
C        Change parity and continue
C
      IP = JP
      JP = 1 - JP
      GOTO 70
  110 CONTINUE
C
C        Lower and upper support of stratum distribution
C
      IZ1 = LBUF(JP, TO(0), 1)
      IZ2 = IZ1 + LBUF(JP, TO(0), 2)
      IP = JP
      RETURN
      END
C
      SUBROUTINE OPT(MC, IJ, IS, X, IT1, IT2)
C
C        ALGORITHM AS 293.3 APPL.STATIST. (1994), VOL.43, NO.3
C
C        Computes optimum values for t given s
C
      INTEGER MC, IJ, IS, X(MC, 0:2), IT1, IT2
C
      INTEGER I, IX, MM
C
C        Compute minimum
C
      IT1 = 0
      IX = IS
      DO 10 I = 1, IJ
         MM = MIN0(IX, X(I, 0))
         IT1 = IT1 + MM * X(I, 2)
         IF (IX .LE. X(I, 0)) THEN
            GOTO 20
         ELSE
            IX = IX - X(I, 0)
         ENDIF
   10 CONTINUE
   20 CONTINUE
      IT2 = 0
      IX = IS
      DO 30 I = IJ, 1, -1
         MM = MIN0(IX, X(I, 0))
         IT2 = IT2 + MM * X(I, 2)
         IF (IX .LE. X(I, 0)) THEN
            RETURN
         ELSE
            IX = IX - X(I, 0)
         ENDIF
   30 CONTINUE
      RETURN
      END
C
      INTEGER FUNCTION LADR(IS, IT, KP, LBUF, IST, MXR)
C
C        ALGORITHM AS 293.4 APPL.STATIST. (1994), VOL.43, NO.3
C
C        Determines an address for (s,t) in the linear array cbuf
C
      INTEGER IS, IT, KP, LBUF(0:1, 0:MXR, 2), IST(0:1), MXR
C
      INTEGER IXT
C
      IXT = IT - LBUF(KP, IS, 1)
      IF (IS .EQ. IST(KP)) THEN
         LADR = IXT
      ELSE
         LADR = LBUF(KP, IS - 1, 2) + IXT + 1
      ENDIF
      RETURN
      END
C
      REAL FUNCTION BNM(K, N, LFACT, MXC)
C
C        ALGORITHM AS 293.5 APPL.STATIST. (1994), VOL.43, NO.3
C
C        Computes binomial coefficient on log-scale
C
      INTEGER K, N, MXC
      REAL LFACT(MXC + 1)
C
      INTEGER L
      REAL DD
C
      L = N - K
      DD = LFACT(N + 1)
      DD = DD - LFACT(L + 1)
      DD = DD - LFACT(K + 1)
      BNM = DD
      RETURN
      END
C
      REAL FUNCTION SUMLG(D1, D2)
C
C        ALGORITHM AS 293.6 APPL.STATIST. (1994), VOL.43, NO.3
C
C        Adds two logarithmic scale numbers
C
      REAL D1, D2
C
      REAL DD, X, ZEXP, ZLOG
C
      ZEXP(X) = EXP(X)
      ZLOG(X) = ALOG(X)
C
      DD = D1
      IF (D2 .GT. D1) DD = D2
      D1 = ZEXP(D1 - DD)
      D2 = ZEXP(D2 - DD)
      DD = ZLOG(D1 + D2) + DD
      SUMLG = DD
      RETURN
      END
